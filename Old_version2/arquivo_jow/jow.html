<!DOCTYPE html>
<html>
<head>
    <title>Fractal de Mandelbrot em 3D com Ray Marching</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>

    <script>
        const canvas = document.getElementById('canvas');
        const gl = canvas.getContext('webgl');

        // Definição dos shaders
        const vertexShaderSource = `
            attribute vec2 position;
            void main() {
                gl_Position = vec4(position, 0.0, 1.0);
            }
        `;

        const fragmentShaderSource = `
        precision highp float;

uniform vec2 resolution;
uniform float zoom;
uniform vec2 pan;

const float maxDist = 20.0;
const int maxIterations = 100;

float sceneSDF(vec3 p) {
    vec2 z = vec2(p.x, p.y);
    int iterations = 0;

    for (int i = 0; i < maxIterations; i++) {
        if (dot(z, z) > 4.0) {
            break;
        }

        float xtemp = z.x * z.x - z.y * z.y + p.x;
        z.y = 2.0 * z.x * z.y + p.y;
        z.x = xtemp;

        iterations++;
    }

    return float(iterations) / float(maxIterations);
}

vec3 estimateNormal(vec3 p) {
    vec2 e = vec2(0.01, 0.0);
    return normalize(vec3(
        sceneSDF(vec3(p + e.xyy)) - sceneSDF(vec3(p - e.xyy)),
        sceneSDF(vec3(p + e.yxy)) - sceneSDF(vec3(p - e.yxy)),
        sceneSDF(vec3(p + e.yyx)) - sceneSDF(vec3(p - e.yyx))
    ));
}

vec4 rayMarching(vec3 ro, vec3 rd) {
    float totalDist = 0.0;

    for (int i = 0; i < maxIterations; i++) {
        vec3 p = ro + rd * totalDist;
        float dist = sceneSDF(p);
        totalDist += dist;

        if (dist < 0.001 || totalDist > maxDist) {
            break;
        }
    }

    if (totalDist > maxDist) {
        return vec4(0.0);
    }

    return vec4(totalDist, 0.0, 0.0, 1.0);
}

vec3 getLighting(vec3 p, vec3 normal) {
    vec3 lightDir = normalize(vec3(0.5, 1.0, -0.5));
    float intensity = max(dot(normal, lightDir), 0.0);
    return vec3(intensity);
}

vec4 render(vec3 ro, vec3 rd) {
    vec4 color = vec4(0.0);

    vec4 intersection = rayMarching(ro, rd);

    if (intersection.x > 0.0) {
        vec3 p = ro + rd * intersection.x;
        vec3 normal = estimateNormal(p);
        vec3 lighting = getLighting(p, normal);
        color = vec4(lighting, 1.0);
    }

    return color;
}

void main() {
    vec2 uv = (gl_FragCoord.xy - resolution.xy / 2.0) / resolution.y;
    uv = vec2(uv.x * resolution.x / resolution.y, uv.y);

    vec3 ro = vec3(0.0, 0.0, -2.0);
    vec3 rd = normalize(vec3(uv, 1.0));
    vec4 fragColor = render(ro, rd);

    gl_FragColor = fragColor;
}
        `;
        // Compilar e vincular shaders
        function compileShader(source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
                return null;
            }
            return shader;
        }

        const vertexShader = compileShader(vertexShaderSource, gl.VERTEX_SHADER);
        const fragmentShader = compileShader(fragmentShaderSource, gl.FRAGMENT_SHADER);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        gl.useProgram(program);

        // Atribuir valores aos atributos
        const positionAttributeLocation = gl.getAttribLocation(program, 'position');
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        const positions = [-1, -1, 1, -1, -1, 1, 1, 1];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(positionAttributeLocation);
        gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);

        // Obter localização das uniformes
        const resolutionUniformLocation = gl.getUniformLocation(program, 'resolution');
        const zoomUniformLocation = gl.getUniformLocation(program, 'zoom');
        const panUniformLocation = gl.getUniformLocation(program, 'pan');

        // Configurar tamanho do canvas
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);

        // Função para renderizar o fractal
        function renderFractal() {
            gl.uniform2f(resolutionUniformLocation, canvas.width, canvas.height);

            // Ajuste os valores de zoom e pan para controlar a área do fractal exibida
            const zoom = 3.0;
            const pan = { x: 0.0, y: 0.0 };
            gl.uniform1f(zoomUniformLocation, zoom);
            gl.uniform2f(panUniformLocation, pan.x, pan.y);

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }

        // Chamada inicial para renderizar o fractal
        renderFractal();

        // Redimensionar o canvas quando a janela for redimensionada
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
            renderFractal();
        });
    </script>
    </body>
</html>
